package com.easyjson.gen;

import com.easyjson.annotation.PreKnowGeneric;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.google.common.hash.HashCode;
import com.oracle.tools.packager.IOUtils;
import com.sun.tools.javac.util.Pair;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.PrintStream;
import java.lang.reflect.Field;
import java.util.*;
import java.util.concurrent.atomic.AtomicReference;

import static com.easyjson.gen.Encoder.PrimitiveEncoders;

/**
 * @Author: author
 * @Description:
 * @Date: 2023/1/8 10:49 上午
 * @Version: 1.0
 */
public class Generator {
    private String fileName;
    PrintStream out;

    String pkgName;
    String hashString;

    int varCounter;

    boolean noStdMarshalers;
    boolean omitEmpty;
    boolean disallowUnknownFields;
    FieldNamer fieldNamer = new DefaultFieldNamer();
    boolean simpleBytes;
    boolean skipMemberNameUnescaping;

    // package path to local alias map for tracking imports
    Map<String, String> imports = new HashMap<>();

    // types that marshalers were requested for by user
    Map<Class, Boolean> marshalers = new HashMap<>();

    // types that encoders were already generated for
    Map<Class, Boolean> typesSeen = new HashMap<>();

    // types that encoders were requested for (e.g. by encoders of other types)
    LinkedList<Class> typesUnseen;

    // function name to relevant type maps to track names of de-/encoders in
    // case of a name clash or unnamed structs
    Map<String, Class> functionNames = new HashMap<>();

    public Generator(String fileName) throws FileNotFoundException {
        this.fileName = fileName;
        this.out = new PrintStream(fileName);
        HashCode hashCode = HashCode.fromString(fileName);
        this.hashString = hashCode.toString();
    }

    public void run() throws IOException {
        while (!typesUnseen.isEmpty()) {
            Class targetClass = typesUnseen.poll();
            typesSeen.put(targetClass,true);
//            genDecoder(targetClass);
            genEncoder(targetClass);
            if (!this.marshalers.get(targetClass)) {
                continue;
            }
            genStructMarshaler(targetClass);
//            genStructUnmarshaler(targetClass);
        }
        Pair<PrintStream, Long> printStreamLongPair = printHeader();
        PrintStream printStream =printStreamLongPair.fst;
        out.flush();
        out.close();
        printStream.write(IOUtils.readFully(new File(fileName)));
        printStream.println("}");
        printStream.flush();
        printStream.close();
        IOUtils.copyFile(new File("tmp-"+fileName+printStreamLongPair.snd),new File(fileName));
    }

    private Pair<PrintStream,Long> printHeader() throws FileNotFoundException {
        HashCode hashCode = HashCode.fromLong(new Random().nextLong());
        PrintStream printStream = new PrintStream("tmp-" + fileName + hashCode.asLong());
        printStream.println("// Code generated by easyjson for marshaling/unmarshaling. DO NOT EDIT.");
        printStream.println();
        printStream.println("package "+ pkgName+";");
        printStream.println();
        imports.forEach((k,v)->{
            printStream.println("import "+v+";");
        });
        printStream.println();
        //print class info
        printStream.println("public class "+fileName+"{");

        return Pair.of(printStream,hashCode.asLong());
    }

    public void genDecoder(Class t) {
        if (List.class.isAssignableFrom(t) || Map.class.isAssignableFrom(t) || t.isArray()) {
            genSliceArrayDecoder(t);
        } else {
            genStructDecoder(t);
        }
    }

    public void genSliceArrayDecoder(Class t) {

    }

    public void genStructDecoder(Class t) {

    }

    public void genEncoder(Class t) {
        if (List.class.isAssignableFrom(t) || Map.class.isAssignableFrom(t) || t.isArray()) {
            genSliceArrayMapEncoder(t);
        } else {
            genStructEncoder(t);
        }
    }

    public void genSliceArrayMapEncoder(Class t) {

    }

    public void genStructEncoder(Class t) {
        String fName = getEncoderName(t);
        String type = getType(t);
        out.println("public void " + fName + "(Writer out ," + type + " in){");
        out.println("  out.RawByte('{'");
        out.println("  boolean first = true");
        List<Field> fs = getStructFields(t);
        boolean firstCondition = true;
        for (int i = 0; i < fs.size(); i++) {
            firstCondition = genStructFieldEncoder(t, fs.get(i), i == 0, firstCondition);
        }
//        if hasUnknownsMarshaler(t) { 暂定不写
//            if !firstCondition {
//                fmt.Fprintln(g.out, "  in.MarshalUnknowns(out, false)")
//            } else {
//                fmt.Fprintln(g.out, "  in.MarshalUnknowns(out, first)")
//            }
//        }
        out.println("  out.RawByte('}')");
        out.println("}");
    }

    public boolean genStructFieldEncoder(Class t, Field f, boolean firstFiled, boolean firstCondition) {
        String jsonName = this.fieldNamer.GetJSONFieldName(t, f);
        AnnotationInfo annotationInfo = parseFieldAnnotation(f);
        boolean toggleFirstCondition = firstCondition;
        boolean noOmitEmpty = !omitEmpty;
        if (noOmitEmpty) {
            out.println("{");
            toggleFirstCondition = false;
        } else {
            out.println("if(" + notEmptyCheck(f, "in." + concatGetFiled(f.getName())) + "){");
        }
        if (firstCondition) {
            out.printf("String prefix = %s;\n", "," + concatQuote(jsonName) + " :");
            if (firstFiled) {
                if (omitEmpty) {
                    out.println("   first = false");
                }
                out.println("out.RawString(prefix.subString(1))");
            } else {
                out.println("   if (first){");
                out.println("      first = false;");
                out.println("out.RawString(prefix.subString(1))");
                out.println("} else {");
                out.println("      out.RawString(prefix)");
                out.println("}");
            }
        } else {
            out.printf("String prefix = %s;\n", "," + concatQuote(jsonName) + " :");
            out.println("      out.RawString(prefix)");
        }
        genTypeEncoder(f.getClass(), "in." + concatGetFiled(f.getName()), annotationInfo, 2, omitEmpty);
        out.println("}");
        return toggleFirstCondition;
    }

    private AnnotationInfo parseFieldAnnotation(Field f) {
        PreKnowGeneric annotation = f.getAnnotation(PreKnowGeneric.class);
        AnnotationInfo annotationInfo = new AnnotationInfo();
        Class list = annotation.list();
        annotationInfo.setlK(list);
        Class[] map = annotation.map();
        annotationInfo.setmKV(map);
        return annotationInfo;
    }

    private void genTypeEncoder(Class t, String in, AnnotationInfo o, int indent, boolean assumeNonEmpty) {
        //todo 可扩展用户自定的序列化类
        genTypeEncoderNoCheck(t, in, o, indent, assumeNonEmpty);
    }

    private void genTypeEncoderNoCheck(Class t, String in, AnnotationInfo o, int indent, boolean assumeNonEmpty) {
        String ws = addIndent(indent);
        if (PrimitiveEncoders.containsKey(t)) {
            out.printf(ws + PrimitiveEncoders.get(t) + "\n", in);
            return;
        }
        if (Collection.class.isAssignableFrom(t)) {
            String iVar = uniqueVarName();
            out.println(ws + "out.RawByte('[')");
            out.println(ws + "for( )");
            if (!assumeNonEmpty) {
                out.println(ws + "if (" + in + " == null) {");
                out.println(ws + "  out.RawString(\"null\")");
                out.println(ws + "} else {");
            } else {
                out.println(ws + "{");
            }
            out.println(ws + "  out.RawByte('[')");
            out.println(ws + "  for (;" + iVar + "<" + in + ".size();" + iVar + "++;){");
            out.println(ws + "    if (" + iVar + " > 0) {");
            out.println(ws + "      out.RawByte(',')");
            out.println(ws + "   }");

            genTypeEncoder(o.getlK(), in + ".get(" + iVar + ");", o, indent + 2, false);

            out.println(ws + "  }");
            out.println(ws + "  out.RawByte(']')");
            out.println(ws + "}");
        }
        if (Map.class.isAssignableFrom(t)) {
            Class[] classes = o.getmKV();
            Class key = classes[0];
            Class value = classes[1];

            String keyEnc = PrimitiveEncoders.get(key);

            String tmpVar = uniqueVarName();

            if (!assumeNonEmpty) {
                out.println(ws + "if(" + in + " == null) {");
                out.println(ws + "  out.RawString(\"null\")");
                out.println(ws + "} else {");
            } else {
                out.println(ws + "{");
            }
            out.println(ws + "  out.RawByte('{');");
            out.println(ws + "  boolean " + tmpVar + "First = true;");
            out.println(ws + in + ".forEach((" + tmpVar + "Name," + tmpVar + "Value)-> {");
            out.println(ws + "    if(" + tmpVar + "First){" + tmpVar + "First = false;} else { out.RawByte(',');}");
            if (keyEnc != null && keyEnc.length() > 0) {
                out.println(ws + "    " + String.format(keyEnc, tmpVar + "Name"));
            } else {
                genTypeEncoder(key, tmpVar + "Name", o, indent + 2, false);
            }
            out.println(ws + " });");
            out.println(ws + "    out.RawByte(':')");

            genTypeEncoder(value, tmpVar + "Value", o, indent + 2, false);

            out.println(ws + "  }");
            out.println(ws + "  out.RawByte('}')");
            out.println(ws + "}");
        }
        if (Object.class.isAssignableFrom(t)) {
            String encName = getEncoderName(t);
            addType(t);
            out.println(ws + encName + "(out," + in + ")");
            return;
        }
        throw new IllegalArgumentException(String.format("%s", t.getName()));
    }

    public void add(Class t){
        addType(t);
        marshalers.put(t,true);
    }

    private void addType(Class t){
        if (typesSeen.containsKey(t)) {
            return ;
        }
        if (typesUnseen.contains(t)) {
            return ;
        }
        typesUnseen.addLast(t);
    }

    private String uniqueVarName() {
        varCounter++;
        return "v" + varCounter;
    }

    private String notEmptyCheck(Field f, String v) {
        String template = "Objects.nonNull(" + v + ") && ";
        if (String.class.isAssignableFrom(f.getClass())) {
            return template + v + ".length() > 0";
        }
        if (Number.class.isAssignableFrom(f.getClass())) {
            return template;
        }
        if (Collection.class.isAssignableFrom(f.getClass())) {
            return template + v + ".isEmpty()";
        }
        if (Map.class.isAssignableFrom(f.getClass())) {
            return template + v + ".isEmpty()";
        }
        return template.substring(0, template.length() - 3);
    }

    public String concatGetFiled(String name) {
        return "get" + name + "()";
    }

    public String concatQuote(String str) {
        return "\"" + str + "\"";
    }

    public String addIndent(int indent) {
        StringBuilder builder = new StringBuilder("  ");
        for (int i = 0; i < indent; i++) {
            builder.append(" ");
        }
        return builder.toString();
    }

    public List<Field> getStructFields(Class t) {
        List<Field> fields = Arrays.asList(t.getDeclaredFields());
        Class clazz;
        while ((clazz = t.getSuperclass()) != null) {
            Field[] declaredFields1 = clazz.getDeclaredFields();
            fields.addAll(Arrays.asList(declaredFields1));
        }
        return fields;
    }

    public String getEncoderName(Class t) {
        return functionNames("endcode", t);
    }

    public String getType(Class t) {
        Package aPackage = t.getPackage();
        String pkgName = aPackage.getName();
        if (this.pkgName != pkgName) {
            imports.putIfAbsent(t.getCanonicalName(),t.getCanonicalName());
        }
        return t.getName();
    }

    /*********split**************/
    public void genStructMarshaler(Class t) {
        String fname = getEncoderName(t);
        String typ = getType(t);
        if (!noStdMarshalers) {
            out.println("public static String MarshalJSON(" + typ + " v) {");
            out.println("  Writer w = new Writer();");
            out.println("  " + fname + "(w, v);");
            out.println("  return w.toJson();");
            out.println("}");
        }
        out.println("public static void MarshalEasyJSON(Writer w) {");
        out.println("  " + fname + "(w, v);");
        out.println("}");

    }

    public void genStructUnmarshaler(Class t) {

    }

    public String functionNames(String prefix, Class t) {
        prefix = joinFunctionNameParts(true, "easyjson", hashString, prefix);
        String name = joinFunctionNameParts(true, prefix, getPkgName(t));
        if (!functionNames.containsKey(name)) {
            functionNames.put(name, t);
            return name;
        }
        String finalPrefix = prefix;
        AtomicReference<String> matchKey = new AtomicReference<String>();
        if (functionNames.entrySet().stream().anyMatch(item -> item.getValue() == t && (matchKey.compareAndSet("", item.getKey().startsWith(
                finalPrefix) ? item.getKey() : "")))) {
            return matchKey.get();
        }
        String tmp;
        for (int i = 0; ; i++) {
            tmp = name + i;
            if (functionNames.containsKey(tmp)) {
                continue;
            }
            functionNames.put(tmp, t);
            return tmp;
        }
    }

    // 包名称 + 路径名最后一个
    public String getPkgName(Class t) {

        return "";
    }

    public String joinFunctionNameParts(boolean keepFirst, String... parts) {
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < parts.length; i++) {
            if (i == 0 && keepFirst) {
                builder.append(parts[i]);
            } else {
                if (parts[i].length() > 0) {
                    builder.append(parts[i].substring(0, 1).toUpperCase());
                }
                if (parts[i].length() > 0) {
                    builder.append(parts[i].substring(1));
                }
            }
        }

        return builder.toString();
    }

    public static void main(String[] args) throws FileNotFoundException {
        Field declaredField = Generator.class.getDeclaredFields()[0];
        System.out.println(declaredField.getName());
    }

    interface FieldNamer {
        String GetJSONFieldName(Class t, Field f);
    }

    class DefaultFieldNamer implements FieldNamer {

        @Override
        public String GetJSONFieldName(Class t, Field f) {
            JsonProperty annotation = f.getAnnotation(JsonProperty.class);
            if (annotation == null) {
                return f.getName();
            }
            return annotation.value();
        }
    }

    class AnnotationInfo {
        private Class[] mKV;

        private Class lK;

        public Class[] getmKV() {
            return mKV;
        }

        public void setmKV(Class[] mKV) {
            this.mKV = mKV;
        }

        public Class getlK() {
            return lK;
        }

        public void setlK(Class lK) {
            this.lK = lK;
        }
    }
}

