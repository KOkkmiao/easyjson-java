package com.easyjson.gen;

import cn.hutool.core.io.IoUtil;
import cn.hutool.core.lang.Pair;
import com.easyjson.annotation.PreKnowGeneric;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.google.common.base.Strings;
import com.google.common.collect.Lists;
import com.google.common.hash.HashCode;
import sun.misc.IOUtils;
import sun.nio.ch.IOUtil;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.lang.reflect.Field;
import java.lang.reflect.TypeVariable;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.*;
import java.util.concurrent.atomic.AtomicReference;

import static com.easyjson.gen.Encoder.PrimitiveEncoders;

/**
 * @Author: author
 * @Description:
 * @Date: 2023/1/8 10:49 上午
 * @Version: 1.0
 */
public class Generator {
    private String fileName;

    private String filePath;
    PrintStream out;

    private String pkgName;
    private String hashString;

    int varCounter;

    boolean noStdMarshalers;
    boolean omitEmpty;
    boolean disallowUnknownFields;
    FieldNamer fieldNamer = new DefaultFieldNamer();
    boolean simpleBytes;
    boolean skipMemberNameUnescaping;

    // package path to local alias map for tracking imports
    Map<String, String> imports = new HashMap<>();

    // types that marshalers were requested for by user
    Map<Class, Boolean> marshalers = new HashMap<>();

    // types that encoders were already generated for
    Map<Class, Boolean> typesSeen = new HashMap<>();

    // types that encoders were requested for (e.g. by encoders of other types)
    LinkedList<Object> typesUnseen = new LinkedList<>();

    Map<Class,Boolean> typeUnseenDuplicate  = new HashMap<>();
    // function name to relevant type maps to track names of de-/encoders in
    // case of a name clash or unnamed structs
    Map<String, Class> functionNames = new HashMap<>();

    public Generator(String fileName) throws FileNotFoundException {
        this.fileName = fileName;
        HashCode hashCode = HashCode.fromLong(fileName.hashCode());
        this.hashString = hashCode.toString();
    }

    public void run() throws IOException, IllegalAccessException {
        if (Strings.isNullOrEmpty(filePath)) {
            URL resource = typesUnseen.getFirst().getClass().getResource("./");
            this.filePath = resource.getPath();
        }
        this.out = new PrintStream(filePath + File.separator +fileName);
        while (!typesUnseen.isEmpty()) {
            Object targetClass = typesUnseen.poll();
            typesSeen.put(targetClass.getClass(), true);
            //            genDecoder(targetClass);
            genEncoder(targetClass);
            if (!this.marshalers.containsKey(targetClass.getClass())) {
                continue;
            }
            genStructMarshaler(targetClass.getClass());
            //            genStructUnmarshaler(targetClass);
        }
        Pair<PrintStream, Long> printStreamLongPair = printHeader();
        PrintStream printStream = printStreamLongPair.getKey();
        out.flush();
        out.close();
        IoUtil.copy(Files.newInputStream(Paths.get(fileName)), printStream);
        printStream.println("}");
        printStream.flush();
        printStream.close();
        IoUtil.copy(Files.newInputStream(Paths.get("tmp-" + fileName + printStreamLongPair.getValue())),
                Files.newOutputStream(Paths.get(fileName)));
    }

    private Pair<PrintStream, Long> printHeader() throws FileNotFoundException {
        HashCode hashCode = HashCode.fromLong(new Random().nextLong());
        PrintStream printStream = new PrintStream("tmp-" + fileName + hashCode.asLong());
        printStream.println("// Code generated by easyjson for marshaling/unmarshaling. DO NOT EDIT.");
        printStream.println();
        printStream.println("package " + pkgName + ";");
        printStream.println();
        printStream.println("import com.easyjson.jwriter.Writer;");
        imports.forEach((k, v) -> {
            printStream.println("import " + v + ";");
        });
        printStream.println();
        //print class info
        printStream.println("public class " + fileName + "{");

        return new Pair<>(printStream, hashCode.asLong());
    }

    public void genDecoder(Class t) {
        if (List.class.isAssignableFrom(t) || Map.class.isAssignableFrom(t) || t.isArray()) {
            genSliceArrayDecoder(t);
        } else {
            genStructDecoder(t);
        }
    }

    public void genSliceArrayDecoder(Class t) {

    }

    public void genStructDecoder(Class t) {

    }

    public void genEncoder(Object t) throws IllegalAccessException {
        if (List.class.isAssignableFrom(t.getClass()) || Map.class.isAssignableFrom(t.getClass()) || t.getClass()
                .isArray()) {
            genSliceArrayMapEncoder(t);
        } else {
            genStructEncoder(t);
        }
    }

    public void genSliceArrayMapEncoder(Object t) {

    }

    public void genStructEncoder(Object t) throws IllegalAccessException {
        String fName = getEncoderName(t.getClass());
        String type = getType(t.getClass());
        out.println("public static void " + fName + "(Writer out ," + type + " in){");
        out.println("  out.RawByte('{');");
        out.println("  boolean first = true;");
        List<Field> fs = getStructFields(t.getClass());
        boolean firstCondition = true;
        for (int i = 0; i < fs.size(); i++) {
            firstCondition = genStructFieldEncoder(t.getClass(), fs.get(i), i == 0, firstCondition, fs.get(i).get(t));
        }
        //        if hasUnknownsMarshaler(t) { 暂定不写
        //            if !firstCondition {
        //                fmt.Fprintln(g.out, "  in.MarshalUnknowns(out, false)")
        //            } else {
        //                fmt.Fprintln(g.out, "  in.MarshalUnknowns(out, first)")
        //            }
        //        }
        out.println("  out.RawByte('}');");
        out.println("}");
    }

    public boolean genStructFieldEncoder(Class t, Field f, boolean firstFiled, boolean firstCondition, Object o) {
        String jsonName = this.fieldNamer.GetJSONFieldName(t, f);
        AnnotationInfo annotationInfo = parseFieldAnnotation(f, o);
        boolean toggleFirstCondition = firstCondition;
        boolean noOmitEmpty = !omitEmpty;
        if (noOmitEmpty) {
            out.println("{");
            toggleFirstCondition = false;
        } else {
            out.println("if(" + notEmptyCheck(f, "in." + concatGetFiled(f.getName())) + "){");
        }
        if (firstCondition) {
            out.printf("String prefix = %s;\n",concatQuote(","+concatQuoteDouble(  jsonName )+ " :"));
            if (firstFiled) {
                if (omitEmpty) {
                    out.println("   first = false");
                }
                out.println("out.RawString(prefix.substring(1));");
            } else {
                out.println("   if (first){");
                out.println("      first = false;");
                out.println("out.RawString(prefix.substring(1));");
                out.println("} else {");
                out.println("      out.RawString(prefix);");
                out.println("}");
            }
        } else {
            out.printf("String prefix = %s;\n",concatQuote( ","+concatQuoteDouble( jsonName )+ " :"));
            out.println("      out.RawString(prefix);");
        }
        genTypeEncoder(f.getType(), "in." + concatGetFiled(f.getName()), annotationInfo, 2, omitEmpty, o);
        out.println("}");
        return toggleFirstCondition;
    }

    private AnnotationInfo parseFieldAnnotation(Field f, Object o) {

        AnnotationInfo annotationInfo = new AnnotationInfo();
        if (Collection.class.isAssignableFrom(f.getType())) {
            Collection o1 = (Collection) o;
            Object value = o1.iterator().next();
            if (value != null) {
                annotationInfo.setlK(value.getClass());
            }
        } else if (Map.class.isAssignableFrom(f.getType())) {
            Map o1 = (Map) o;
            Map.Entry<Object, Object> next = (Map.Entry<Object, Object>) o1.entrySet().iterator().next();
            annotationInfo.setlK(next.getKey().getClass());
            annotationInfo.setmV(next.getValue().getClass());
        } else if (f.getType().isArray()) {
            annotationInfo.setArray(true);
            Object[] o1 = (Object[]) o;
            annotationInfo.setlK(o1[0].getClass());
        } else {
            annotationInfo.setNormal(o.getClass());
        }

        return annotationInfo;
    }

    private void genTypeEncoder(Class t, String in, AnnotationInfo o, int indent, boolean assumeNonEmpty,
            Object target) {
        //todo 可扩展用户自定的序列化类
        genTypeEncoderNoCheck(t, in, o, indent, assumeNonEmpty, target);
    }

    private void genTypeEncoderNoCheck(Class t, String in, AnnotationInfo o, int indent, boolean assumeNonEmpty,
            Object target) {
        String ws = addIndent(indent);
        if (PrimitiveEncoders.containsKey(t)) {
            out.printf(ws + PrimitiveEncoders.get(t) + "\n", in);
            return;
        }
        if (Collection.class.isAssignableFrom(t)) {
            String iVar = uniqueVarName();
            if (!assumeNonEmpty) {
                out.println(ws + "if (" + in + " == null) {");
                out.println(ws + "  out.RawString(\"null\");");
                out.println(ws + "} else {");
            } else {
                out.println(ws + "{");
            }
            out.println(ws + "  out.RawByte('[');");
            out.println(ws + "  for (int "+ iVar + " = 0;" + iVar + "<" + in + ".size();" + iVar + "++){");
            out.println(ws + "    if (" + iVar + " > 0) {");
            out.println(ws + "      out.RawByte(',');");
            out.println(ws + "   }");

            genTypeEncoder(o.getlK(),
                    in + ".get(" + iVar + ")",
                    o,
                    indent + 2,
                    false,
                    ((Collection) target).iterator().next());

            out.println(ws + "  }");
            out.println(ws + "  out.RawByte(']');");
            out.println(ws + "}");
            return;
        }
        if (Map.class.isAssignableFrom(t)) {
            Class key = o.getlK();
            Class value = o.getmV();

            String keyEnc = PrimitiveEncoders.get(key);

            String tmpVar = uniqueVarName();

            if (!assumeNonEmpty) {
                out.println(ws + "if(" + in + " == null) {");
                out.println(ws + "  out.RawString(\"null\");");
                out.println(ws + "} else {");
            } else {
                out.println(ws + "{");
            }
            out.println(ws + "  out.RawByte('{');");
            out.println(ws + in + ".forEach((" + tmpVar + "Name," + tmpVar + "Value)-> {");

            Map o1 = (Map) target;
            Map.Entry<Object, Object> next = (Map.Entry<Object, Object>) o1.entrySet().iterator().next();
            if (keyEnc != null && keyEnc.length() > 0) {
                out.println(ws + "    " + String.format(keyEnc, tmpVar + "Name"));
            } else {
                genTypeEncoder(key, tmpVar + "Name", o, indent + 2, false, next.getKey());
            }

            out.println(ws + "    out.RawByte(':');");

            genTypeEncoder(value, tmpVar + "Value", o, indent + 2, false, next.getValue());
            out.println(ws+"out.RawByte(',');");
            out.println(ws + " });");
            // 截取最后一个字符
            out.println(ws+"out.subLastDot();");
            out.println(ws + "  }");
            out.println(ws + "  out.RawByte('}');");
            return;
        }
        if (t.isArray()) {
            Class lk = o.getlK();
            String iVar = uniqueVarName();
            out.println(ws + "out.RawByte('[')");
            out.println(ws + "  for (;" + iVar + "<" + in + ".length;" + iVar + "++;){");
            out.println(ws + "    if (" + iVar + " > 0) {");
            out.println(ws + "      out.RawByte(',')");
            out.println(ws + "   }");
            genTypeEncoder(lk,
                    "(" + in + ")[" + iVar + "]",
                    o,
                    indent + 2,
                    false,
                    ((Collection) target).iterator().next());
            out.println(ws + "}");
            out.println(ws + "out.RawByte(']')");
            return;
        }
        if (Object.class.isAssignableFrom(t)) {
            String encName = getEncoderName(t);
            addType(target);
            out.println(ws + encName + "(out," + in + ");");
            return;
        }
        throw new IllegalArgumentException(String.format("%s", t.getName()));
    }

    public void add(Object t) {
        addType(t);
        marshalers.put(t.getClass(), true);
    }

    private void addType(Object t) {
        if (typesSeen.containsKey(t.getClass())) {
            return;
        }
        if (typeUnseenDuplicate.containsKey(t.getClass())) {
            return;
        }
        typesUnseen.addLast(t);
        typeUnseenDuplicate.put(t.getClass(),true);
    }

    private String uniqueVarName() {
        varCounter++;
        return "v" + varCounter;
    }

    private String notEmptyCheck(Field f, String v) {
        String template = "Objects.nonNull(" + v + ") && ";
        if (String.class.isAssignableFrom(f.getClass())) {
            return template + v + ".length() > 0";
        }
        if (Number.class.isAssignableFrom(f.getClass())) {
            return template;
        }
        if (Collection.class.isAssignableFrom(f.getClass())) {
            return template + v + ".isEmpty()";
        }
        if (Map.class.isAssignableFrom(f.getClass())) {
            return template + v + ".isEmpty()";
        }
        return template.substring(0, template.length() - 3);
    }

    public String concatGetFiled(String name) {
        return "get" + name.substring(0, 1).toUpperCase() + name.substring(1) + "()";
    }

    public String concatQuote(String str) {
        return "\"" + str + "\"";
    }
    public String concatQuoteDouble(String str) {
        return "\\\"" + str + "\\\"";
    }
    public String addIndent(int indent) {
        StringBuilder builder = new StringBuilder("  ");
        for (int i = 0; i < indent; i++) {
            builder.append(" ");
        }
        return builder.toString();
    }

    public List<Field> getStructFields(Class t) {
        List<Field> fields = Arrays.asList(t.getDeclaredFields());
        Class clazz = t;
        while ((clazz = clazz.getSuperclass()) != null) {
            Field[] declaredFields1 = clazz.getDeclaredFields();
            fields.addAll(Arrays.asList(declaredFields1));
        }
        fields.forEach(field -> field.setAccessible(true));
        return fields;
    }

    public String getEncoderName(Class t) {
        return functionNames("endcode", t);
    }

    public String getType(Class t) {
        Package aPackage = t.getPackage();
        String pkgName = aPackage.getName();
        if (this.pkgName != pkgName) {
            imports.putIfAbsent(t.getCanonicalName(), t.getCanonicalName());
        }
        return t.getSimpleName();
    }

    /*********split**************/
    public void genStructMarshaler(Class t) {
        String fname = getEncoderName(t);
        String typ = getType(t);
        if (!noStdMarshalers) {
            out.println("public static String MarshalJSON(" + typ + " v) {");
            out.println("  Writer w = new Writer();");
            out.println("  " + fname + "(w, v);");
            out.println("  return w.toJson();");
            out.println("}");
        }
        out.println("public static void MarshalEasyJSON(Writer w," + typ + " v) {");
        out.println("  " + fname + "(w, v);");
        out.println("}");
    }

    public void genStructUnmarshaler(Class t) {

    }

    public String functionNames(String prefix, Class t) {
        prefix = joinFunctionNameParts(true, "easyjson", hashString, prefix);
        String name = joinFunctionNameParts(true, prefix, getPkgName(t));
        if (!functionNames.containsKey(name)) {
            functionNames.put(name, t);
            return name;
        }
        String finalPrefix = prefix;
        if (functionNames.entrySet()
                .stream()
                .anyMatch(item -> item.getValue() == t && item.getKey().startsWith(finalPrefix))) {
            return name;
        }
        String tmp;
        for (int i = 0; ; i++) {
            tmp = name + i;
            if (functionNames.containsKey(tmp)) {
                continue;
            }
            functionNames.put(tmp, t);
            return tmp;
        }
    }

    // 包名称 + 路径名最后一个
    public String getPkgName(Class t) {
        return t.getName().replaceAll("\\.","");
    }

    public String joinFunctionNameParts(boolean keepFirst, String... parts) {
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < parts.length; i++) {
            if (i == 0 && keepFirst) {
                builder.append(parts[i]);
            } else {
                if (parts[i].length() > 0) {
                    builder.append(parts[i].substring(0, 1).toUpperCase());
                }
                if (parts[i].length() > 0) {
                    builder.append(parts[i].substring(1));
                }
            }
        }

        return builder.toString();
    }
    public String getPkgName() {
        return pkgName;
    }
    public void setPkgName(String pkgName) {
        this.pkgName = pkgName;
    }
    public String getFilePath() {
        return filePath;
    }
    public void setFilePath(String filePath) {
        this.filePath = filePath;
    }
    interface FieldNamer {
        String GetJSONFieldName(Class t, Field f);
    }


    class DefaultFieldNamer implements FieldNamer {

        @Override
        public String GetJSONFieldName(Class t, Field f) {
            JsonProperty annotation = f.getAnnotation(JsonProperty.class);
            if (annotation == null) {
                return f.getName();
            }
            return annotation.value();
        }
    }


    class AnnotationInfo {
        private Class normal;
        private Class mV;

        private Class lK;

        private boolean isArray;
        public Class getNormal() {
            return normal;
        }
        public void setNormal(Class normal) {
            this.normal = normal;
        }
        public Class getmV() {
            return mV;
        }
        public void setmV(Class mV) {
            this.mV = mV;
        }
        public Class getlK() {
            return lK;
        }
        public void setlK(Class lK) {
            this.lK = lK;
        }
        public boolean isArray() {
            return isArray;
        }
        public void setArray(boolean array) {
            isArray = array;
        }

    }

}
